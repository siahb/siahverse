<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>📝 Siah To Do</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="todo.css">
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
</head>
<body>
  <canvas id="stars"></canvas>

  <!-- Theme Toggle -->
  <div id="toggle-theme" class="theme-switch">
    <label class="theme-switch">
      <input type="checkbox" id="toggle-theme-checkbox">
      <span class="slider"></span>
    </label>
  </div>

  <div class="container">
    <div class="top-bar">
      <div class="button-group">
        <button id="enter-password">🔐 Enter Password</button>
        <button id="logout">🚪 Logout</button>
      </div>
      <h1><span>✅</span> Siah To Do</h1>
    </div>
  </div>

  <div class="main-content">
    
    <!-- To Do List -->
    <div id="todo-container" class="card-container">
      <h2>To Do List</h2>
      
<!-- Top toolbar -->
<div class="toolbar top">
  <input id="search-input" type="text" placeholder="Search…" />

  <select id="sort-select">
    <option value="default">Sort: Custom (drag)</option>
    <option value="dueAsc">Due date ↑</option>
    <option value="dueDesc">Due date ↓</option>
    <option value="alpha">A–Z</option>
    <option value="created">Newest</option>
  </select>

  <button id="export-btn">Export</button>
  <input type="file" id="import-file" style="display: none;">
<label for="import-file" class="btn">Import</label>
</div>

<!-- Progress bar -->
<div id="progress-wrap" style="width:100%;height:10px;background:rgba(255,255,255,.08);border:1px solid var(--card-border);border-radius:6px;overflow:hidden;margin:.25rem 0 .5rem;">
  <div id="progress-bar" style="height:100%;width:0%;background:#00ffc3;transition:width .3s;"></div>
</div>
<div id="progress-label" style="font-size:.9rem;opacity:.8;"></div>

<input type="text" id="todo-input" placeholder="Type a task and hit Enter..." />

<!-- Tags + Priority below enter -->
<div class="toolbar below-enter">
  <label for="edit-tags" class="tag-label">Tags:</label>
  <input id="tag-input" type="text" placeholder="chores, projects, etc...">
    
  <select id="priority-select">
    <option value="">Priority: none</option>
    <option value="H">High 🔥</option>
    <option value="M">Medium ⚡</option>
    <option value="L">Low 🌿</option>
  </select>
</div>
      
      <div class="repeat-row">
  <label>Due:
    <input type="date" id="due-input">
  </label>

  <label>Repeat:
    <select id="repeat-select">
      <option value="">None</option>
      <option value="daily">Daily</option>
      <option value="weekly">Weekly</option>
    </select>
  </label>

  <label id="interval-wrap" style="display:none;">Every
    <input type="number" id="interval-input" min="1" value="1" style="width:4rem;">
    <span class="interval-unit">day(s)</span>
  </label>

  <div id="weekly-wrap" style="display:none; gap:.4rem; align-items:center;">
    <span>Days:</span>
    <label><input type="checkbox" value="0" class="byweekday">Su</label>
    <label><input type="checkbox" value="1" class="byweekday">Mo</label>
    <label><input type="checkbox" value="2" class="byweekday">Tu</label>
    <label><input type="checkbox" value="3" class="byweekday">We</label>
    <label><input type="checkbox" value="4" class="byweekday">Th</label>
    <label><input type="checkbox" value="5" class="byweekday">Fr</label>
    <label><input type="checkbox" value="6" class="byweekday">Sa</label>
  </div>
</div>
      <div class="controls">
        <label><input type="checkbox" id="select-all"> Select All</label>
        <button id="delete-btn" onclick="deleteSelected()">
          <span class="emoji">🗑️</span> Delete Selected
        </button>
        <button id="undo-btn">↩️ Undo</button>
        <button id="toggle-drag">↕️ Reorder</button>
      </div>
      <ul id="todo-list"></ul>
    </div>

    <!-- Done List -->
    <div id="done-container" class="card-container">
      <h2>Marked as Done ✅</h2>
      <ul id="done-list"></ul>
    </div>
  </div>

  <!-- Admin Modal -->
  <div id="admin-modal" class="modal">
    <div class="modal-content">
      <h2>Admin Login</h2>
      <input type="password" id="password-input" placeholder="Password" />
      <div class="modal-buttons">
        <button id="login-btn">Login</button>
        <button id="cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- ✅ Back Button -->
  <div class="back-button-wrapper">
    <a href="https://siahverse.cc/" class="back-button">Back to Portal</a>
  </div>

<script>
  
  const todoInput = document.getElementById('todo-input');
  const todoList = document.getElementById('todo-list');
  const doneList = document.getElementById('done-list');
  const undoBtn = document.getElementById('undo-btn');
  const selectAll = document.getElementById('select-all');
  const themeCheckbox = document.getElementById('toggle-theme-checkbox');
  const dueInput = document.getElementById('due-input');
  const repeatSelect = document.getElementById('repeat-select');
  const intervalWrap = document.getElementById('interval-wrap');
  const intervalInput = document.getElementById('interval-input');
  const intervalUnit = document.querySelector('.interval-unit');
  const weeklyWrap = document.getElementById('weekly-wrap');
  // toolbar controls
  const searchInput = document.getElementById('search-input');   // Search…
  const sortSelect  = document.getElementById('sort-select');    // Sort: …
  const tagInput    = document.getElementById('tag-input');      // Tags
  const prioSelect  = document.getElementById('priority-select');// Priority: …
  const exportBtn   = document.getElementById('export-btn');     // Export
  const importFile  = document.getElementById('import-file');    // Import (file input)
  searchInput?.addEventListener('input', () => { renderTodos(); renderDone(); });
  sortSelect?.addEventListener('change', () => { renderTodos(); });
  repeatSelect.addEventListener('change', () => {
  const v = repeatSelect.value;
  intervalWrap.style.display = v ? '' : 'none';
  intervalUnit.textContent = v === 'weekly' ? 'week(s)' : 'day(s)';
  weeklyWrap.style.display = v === 'weekly' ? 'flex' : 'none';
});
  
  const enterPwBtn = document.getElementById('enter-password');
  const logoutBtn = document.getElementById('logout');
  const adminModal = document.getElementById('admin-modal');
  const loginBtn = document.getElementById('login-btn');
  const cancelBtn = document.getElementById('cancel-btn');
  const passwordInput = document.getElementById('password-input');

  let todosData = [];
  let deletedTodos = [];
  const ADMIN_PASSWORD_KEY = 'adminPassword';

  // Button visibility
function updateAdminUI() {
  const pw = localStorage.getItem(ADMIN_PASSWORD_KEY);
  const isLoggedIn = !!pw;

  document.getElementById('enter-password').style.display = isLoggedIn ? 'none' : 'inline-block';
  document.getElementById('logout').style.display = isLoggedIn ? 'inline-block' : 'none';
}

  // Theme
  const savedTheme = localStorage.getItem('theme') || 'dark';

  if (savedTheme === 'light') {
    document.body.classList.add('light-mode'); // light variables
    themeCheckbox.checked = false;             // unchecked = light
  } else {
    themeCheckbox.checked = true;              // checked = dark
  }

  themeCheckbox.addEventListener('change', () => {
    const darkOn = themeCheckbox.checked;      // checked means dark
    document.body.classList.toggle('light-mode', !darkOn);
    localStorage.setItem('theme', darkOn ? 'dark' : 'light');
  });

  // Admin
  enterPwBtn.addEventListener('click', () => adminModal.style.display = 'block');
  cancelBtn.addEventListener('click', () => adminModal.style.display = 'none');
  loginBtn.addEventListener('click', async () => {
  const pw = passwordInput.value.trim();
  if (!pw) return alert("Password cannot be empty.");

  // Send a harmless request to test the password
  const res = await fetch('/todos/0', {
    method: 'DELETE',
    headers: {
      Authorization: `Bearer ${pw}`
    }
  });

  if (res.status === 401) {
    alert("❌ Incorrect password.");
  } else {
    localStorage.setItem(ADMIN_PASSWORD_KEY, pw);
    alert("✅ Admin logged in!");
    todoInput.disabled = false;
    adminModal.style.display = 'none';
    updateAdminUI();
  }
});

  logoutBtn.addEventListener('click', () => {
    localStorage.removeItem(ADMIN_PASSWORD_KEY);
    alert("Logged out.");
    todoInput.disabled = true;
    updateAdminUI();
  });
  if (!localStorage.getItem(ADMIN_PASSWORD_KEY)) todoInput.disabled = true;

  // Load Todos from server
async function loadTodosFromServer() {
  try {
    const res = await fetch('/todos');
    todosData = await res.json();

    // Normalize any overdue repeating tasks client-side
    let changed = false;
    for (let i = 0; i < todosData.length; i++) {
      const t = todosData[i];
      if (t && t.repeat) {
        if (rollForwardIfMissed(t)) {
          // persist normalization
          changed = true;
          await fetch(`/todos/${i}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ due: t.due, nextDue: t.nextDue })
          });
        }
      }
    }

    renderTodos();
    renderDone();
  } catch {
    alert("Failed to load todos.");
  }
}

  // ==== Repeats Helpers ====
function todayISO() { return new Date().toISOString().slice(0,10); }

function toISO(d) {
  if (!d) return null;
  if (typeof d === 'string') return d.slice(0,10);
  return new Date(d).toISOString().slice(0,10);
}
function addDays(iso, n){
  const d = new Date(iso || todayISO());
  d.setDate(d.getDate()+n);
  return toISO(d);
}
function isOverdue(todo){
  if (!todo.due) return false;
  return toISO(todo.due) < todayISO() && !todo.done;
}

function filteredTodos(list){
  const q = (searchInput?.value || '').toLowerCase().trim();
  if (!q) return list;
  return list.filter(t =>
    (t.text || '').toLowerCase().includes(q) ||
    (t.tags || []).some(tag => (tag || '').toLowerCase().includes(q))
  );
}

function sortTodos(list){
  const mode = sortSelect?.value || 'default';
  const copy = [...list];
  if (mode === 'dueAsc') {
    copy.sort((a,b)=>(a.due||'9999') < (b.due||'9999') ? -1 : 1);
  } else if (mode === 'dueDesc') {
    copy.sort((a,b)=>(a.due||'0000') > (b.due||'0000') ? -1 : 1);
  } else if (mode === 'alpha') {
    copy.sort((a,b)=> (a.text||'').localeCompare(b.text||''));
  } else if (mode === 'created') {
    copy.sort((a,b)=> (b.createdAt||0) - (a.createdAt||0));
  }
  return copy;
}

function updateProgress(){
  const total = todosData.length;
  const done  = todosData.filter(t=>t.done).length;
  const overdue = todosData.filter(t=>!t.done && t.due && toISO(t.due) < todayISO()).length;
  const pct = total ? Math.round((done/total)*100) : 0;

  const bar = document.getElementById('progress-bar');
  const label = document.getElementById('progress-label');
  if (!bar || !label) return;

  bar.style.width = `${pct}%`;
  label.textContent = total
    ? `${done}/${total} tasks • ${pct}% complete${overdue ? ` • ${overdue} overdue` : ''}`
    : 'No tasks yet';
}

// Compute the next scheduled date from a given 'from' date
function computeNextDue(task, fromISO) {
  const rep = task.repeat;
  if (!rep) return task.due || null;

  const base = new Date(fromISO || (task.nextDue || task.due || todayISO()));
  if (rep.freq === 'daily') {
    const interval = Math.max(1, rep.interval || 1);
    base.setDate(base.getDate() + interval);
    return toISO(base);
  }
  if (rep.freq === 'weekly') {
    const interval = Math.max(1, rep.interval || 1);
    const days = Array.isArray(rep.byWeekday) && rep.byWeekday.length ? [...rep.byWeekday].sort() : [base.getDay()];
    const todayIdx = base.getDay();

    // find next listed weekday strictly after 'base'
    for (const wd of days) {
      const diff = (wd - todayIdx + 7) % 7;
      if (diff > 0) { base.setDate(base.getDate() + diff); return toISO(base); }
    }
    // none left this week → jump to first day in the next interval block
    const first = days[0];
    const toNextBlock = (7 * interval) - ((todayIdx - first + 7) % 7);
    base.setDate(base.getDate() + toNextBlock);
    return toISO(base);
  }
  return task.due || null;
}

// Bring overdue repeating tasks forward to today-or-future
function rollForwardIfMissed(task) {
  if (!task.repeat) return false;
  const next = toISO(task.nextDue || task.due);
  if (!next) return false;

  let cur = next;
  const t = todayISO();
  let moved = false;
  while (cur < t) {
    cur = computeNextDue(task, cur);
    moved = true;
  }
  if (moved) {
    task.nextDue = cur;
    task.due = cur;
  }
  return moved;
}

// Pretty pills for UI
function repeatLabel(task){
  if (!task.repeat) return '';
  if (task.repeat.freq === 'daily') return `Repeats daily (every ${task.repeat.interval||1}d)`;
  if (task.repeat.freq === 'weekly') {
    const map = ['Su','Mo','Tu','We','Th','Fr','Sa'];
    const wd = (task.repeat.byWeekday||[]).map(x=>map[x]).join(',');
    return `Repeats weekly${wd?` (${wd})`:''} (every ${task.repeat.interval||1}w)`;
  }
  return '';
}
  
  // Build weekday checkboxes for the editor
function weekdayBoxes(selected = []) {
  const map = ['Su','Mo','Tu','We','Th','Fr','Sa'];
  return map.map((lbl,i)=>`
    <label style="margin-right:.5rem;">
      <input type="checkbox" class="edit-byweekday" value="${i}" ${selected.includes(i)?'checked':''}>
      ${lbl}
    </label>
  `).join('');
}

// Render Todos
const renderTodos = () => {
  todoList.innerHTML = '';
  const base = todosData.filter(t => !t.done);
  const view = sortTodos(filteredTodos(base));

  view.forEach((todo) => {
    const i = todosData.indexOf(todo); // true index in the data array
    const li = document.createElement('li');
    li.setAttribute('data-trueindex', i);
    li.style.animationDelay = `${Math.random() * 0.5}s`;

    const overduePill = isOverdue(todo) ? `<span class="pill overdue">Overdue</span>` : '';

    // Map priority to !, !!, !!!
    let prioSymbol = '';
    if (todo.priority === 'L') prioSymbol = '!';
    else if (todo.priority === 'M') prioSymbol = '!!';
    else if (todo.priority === 'H') prioSymbol = '!!!';

    const prioPill = todo.priority ? `<span class="pill">${prioSymbol}</span>` : '';
    const tagPills = (todo.tags || []).map(t => `<span class="pill">${t}</span>`).join(' ');

    li.innerHTML = `
      <input type="checkbox" class="select-todo" data-trueindex="${i}" />
      <span class="todo-text">${todo.text}</span>
      <div class="todo-meta">
        ${todo.due ? `<span class="pill due">Due: ${toISO(todo.due)}</span>` : ''}
        ${todo.repeat ? `<span class="pill repeat">${repeatLabel(todo)}</span>` : ''}
        ${overduePill} ${prioPill} ${tagPills}
      </div>
      <div>
        <button onclick="markAsDone(this.closest('li').getAttribute('data-trueindex'))">✅</button>
        <button onclick="editTodo(this.closest('li').getAttribute('data-trueindex'))">✏️</button>
        <button onclick="removeTodo(this.closest('li').getAttribute('data-trueindex'))">❌</button>
      </div>`;
    
    todoList.appendChild(li);
  });

  updateProgress();
  
  // Reset Select All
  selectAll.checked = false;

  // Auto-sync Select All if all checkboxes are toggled
  document.querySelectorAll('.select-todo').forEach(cb => {
    cb.addEventListener('change', () => {
      const all = document.querySelectorAll('.select-todo');
      const checked = document.querySelectorAll('.select-todo:checked');
      selectAll.checked = all.length > 0 && checked.length === all.length;
    });
  });
};
  
// Render Done
const renderDone = () => {
doneList.innerHTML = '';
const view = filteredTodos(todosData.filter(t=>t.done));
view.forEach((todo) => {
  const i = todosData.indexOf(todo);

    const li = document.createElement('li');
    li.classList.add('done');
    li.setAttribute('data-trueindex', i);
    li.style.animationDelay = `${Math.random() * 0.5}s`; // ✅ pulse offset

    li.innerHTML = `
      <span>${todo.text}</span>
      <div>
        <button onclick="unmarkDone(${i})">↩️</button>
        <button onclick="removeTodo(${i})">❌</button>
      </div>`;

    doneList.appendChild(li);
  });
    updateProgress();
};

  
// Inline editor for text + due + repeat + tags
window.editTodo = function(index){
  const li = document.querySelector(`li[data-trueindex="${index}"]`);
  if (!li) return;
  const todo = todosData[index] || {};

  const text = todo.text ?? '';
  const due = (todo.due || '').toString().slice(0,10);
  const rep = todo.repeat || null;
  const freq = rep?.freq || '';
  const interval = rep?.interval || 1;
  const byWeekday = Array.isArray(rep?.byWeekday) ? rep.byWeekday : [];
  const tagsCSV = (todo.tags || []).join(', ');

  li.innerHTML = `
    <div class="edit-container">
      <input type="text" class="edit-text" value="${text}" />
      <label>Due:
        <input type="date" class="edit-due" value="${due}">
      </label>
      <label>Repeat:
        <select class="edit-repeat">
          <option value="" ${!freq?'selected':''}>None</option>
          <option value="daily" ${freq==='daily'?'selected':''}>Daily</option>
          <option value="weekly" ${freq==='weekly'?'selected':''}>Weekly</option>
        </select>
      </label>
      <label class="edit-interval-wrap" style="${freq?'':'display:none;'}">
        Every
        <input type="number" class="edit-interval" min="1" value="${interval}" style="width:4rem;">
        <span class="edit-interval-unit">${freq==='weekly'?'week(s)':'day(s)'}</span>
      </label>
      <div class="edit-weekly-wrap" style="display:${freq==='weekly'?'flex':'none'};align-items:center;">
        <span style="margin-right:.25rem;">Days:</span>
        ${weekdayBoxes(byWeekday)}
      </div>

      <!-- ✅ New: Tags editor -->
      <label>Tags:
        <input type="text" class="edit-tags" placeholder="chores, projects, etc..." value="${tagsCSV}">
      </label>

      <button class="btn-save">Save</button>
      <button class="btn-cancel">Cancel</button>
    </div>
  `;

  // toggles
  const sel = li.querySelector('.edit-repeat');
  const intWrap = li.querySelector('.edit-interval-wrap');
  const intUnit = li.querySelector('.edit-interval-unit');
  const weeklyWrap = li.querySelector('.edit-weekly-wrap');

  sel.addEventListener('change', () => {
    const v = sel.value;
    intWrap.style.display = v ? '' : 'none';
    intUnit.textContent = v==='weekly' ? 'week(s)' : 'day(s)';
    weeklyWrap.style.display = v==='weekly' ? 'flex' : 'none';
  });

  // cancel -> re-render
  li.querySelector('.btn-cancel').onclick = () => { renderTodos(); };

  // save -> PATCH
  li.querySelector('.btn-save').onclick = async () => {
    const newText = li.querySelector('.edit-text').value.trim();
    const newDue = li.querySelector('.edit-due').value || null;
    const newFreq = sel.value;
    const newInterval = parseInt(li.querySelector('.edit-interval')?.value || '1',10);

    // ✅ parse tags
    const tagsVal = li.querySelector('.edit-tags').value || '';
    const tags = tagsVal
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);

    let repeat = null;
    if (newFreq) {
      repeat = { freq: newFreq, interval: Math.max(1,newInterval) };
      if (newFreq === 'weekly') {
        repeat.byWeekday = [...li.querySelectorAll('.edit-byweekday:checked')].map(cb => parseInt(cb.value,10));
      }
    }

    // Build patch; recompute nextDue when repeating
    const patch = { text: newText || todo.text, due: newDue, tags };
    if (repeat) {
      patch.repeat = repeat;
      const temp = { ...todo, repeat, due: newDue || (todo.due || todayISO()) };
      patch.nextDue = computeNextDue(temp, temp.due);
    } else {
      patch.repeat = null;
      patch.nextDue = null;
    }

    try {
      await fetch(`/todos/${index}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(patch)
      });
      await loadTodosFromServer();
    } catch {
      alert('Failed to save changes.');
    }
  };
};

// Add new todo (supports repeats, priority, tags)
todoInput.addEventListener('keydown', async (e) => {
  if (e.key !== 'Enter' || !todoInput.value.trim()) return;
  if (!localStorage.getItem(ADMIN_PASSWORD_KEY)) return alert("Admin only");

  const text = todoInput.value.trim();
  const due = dueInput.value ? dueInput.value : null;

  // Build repeat object if selected
  let repeat = null;
  if (repeatSelect.value) {
    repeat = {
      freq: repeatSelect.value, // 'daily' | 'weekly'
      interval: Math.max(1, parseInt(intervalInput.value || '1', 10))
    };
    if (repeatSelect.value === 'weekly') {
      repeat.byWeekday = [...document.querySelectorAll('.byweekday:checked')]
        .map(cb => parseInt(cb.value, 10));
    }
  }

  // Priority and tags
  const priority = prioSelect.value || null;
  const tags = tagInput.value
    ? tagInput.value.split(',').map(t => t.trim()).filter(Boolean)
    : [];

  // Build the payload
  const payload = {
    text,
    done: false,
    due: due || (repeat ? todayISO() : null),
    repeat,
    lastDone: null,
    tags,
    priority,
    createdAt: Date.now(),
  };

  // If repeating, pre-compute nextDue and ensure a visible due
  if (repeat) {
    payload.nextDue = computeNextDue(payload, payload.due);
    payload.due = payload.due || payload.nextDue;
  }

  try {
    await fetch('/todos', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    // Reset inputs
    todoInput.value = '';
    dueInput.value = '';
    repeatSelect.value = '';
    intervalInput.value = '1';
    document.querySelectorAll('.byweekday').forEach(cb => cb.checked = false);
    // hide repeat UI rows again
    intervalWrap.style.display = 'none';
    weeklyWrap.style.display = 'none';
    // clear priority/tags
    prioSelect.value = '';
    tagInput.value = '';

    await loadTodosFromServer();
  } catch {
    alert("Failed to add todo.");
  }
});

// Mark as done OR advance repeating task
window.markAsDone = async (index) => {
  const task = todosData[index];
  if (!task) return;

  // If it's a repeating task, advance dates instead of moving to Done
if (task.repeat) {
  const nowISO = todayISO();
  const updates = { lastDone: nowISO };
  const startFrom = toISO(task.nextDue || task.due || nowISO);

  // always advance at least one occurrence
  let next = computeNextDue(task, startFrom);
  while (next <= nowISO) next = computeNextDue(task, next);

  updates.nextDue = next;
  updates.due = next;

  try {
    await fetch(`/todos/${index}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates)
    });
    await loadTodosFromServer();
  } catch {
    alert("Failed to advance repeating task.");
  }
  return;
}

  // Non-repeating: behave as before
  try {
    await fetch(`/todos/${index}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ done: true })
    });
    await loadTodosFromServer();
  } catch {
    alert("Failed to mark as done.");
  }
};

  //Unmark done
window.unmarkDone = async (index) => {
  try {
    await fetch(`/todos/${index}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ done: false })
    });
    await loadTodosFromServer();
  } catch {
    alert("Failed to move back to To Do.");
  }
};

  // Remove todo
  window.removeTodo = async (i) => {
    if (!localStorage.getItem(ADMIN_PASSWORD_KEY)) return alert("Admin only");
    deletedTodos.push(todosData[i]); // save full object
    try {
      await fetch(`/todos/${i}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${localStorage.getItem(ADMIN_PASSWORD_KEY)}`
        }
      });
      await loadTodosFromServer();
    } catch {
      alert("Failed to delete.");
    }
  };

  // Undo button
 undoBtn.addEventListener('click', async () => {
  if (!deletedTodos.length) return;

  const restoring = [...deletedTodos]; // Clone to avoid timing issues
  deletedTodos = [];

for (const obj of restoring) {
  await fetch('/todos', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(obj) // send full object
  });
}

  loadTodosFromServer();
});

  // Select all checkbox
  selectAll.addEventListener('change', (e) => {
    document.querySelectorAll('.select-todo').forEach(cb => cb.checked = e.target.checked);
  });

  window.deleteSelected = () => {
    if (!localStorage.getItem(ADMIN_PASSWORD_KEY)) return alert("Admin only");
    const selected = [...document.querySelectorAll('.select-todo:checked')].map(cb => parseInt(cb.dataset.trueindex));
    selected.sort((a,b) => b-a);
    selected.forEach(i => {
      window.removeTodo(i);
    });
  };

  //Toggle Drag mode
let dragEnabled = false;
let sortableInstance = null;

const toggleDragBtn = document.getElementById('toggle-drag');

toggleDragBtn.addEventListener('click', () => {
  dragEnabled = !dragEnabled;

  if (dragEnabled) {
    toggleDragBtn.textContent = '↕️ Reordering...';
    document.body.classList.add('dragging-active'); // 👈 add this
    enableDrag();
  } else {
    toggleDragBtn.textContent = '↕️ Reorder';
    document.body.classList.remove('dragging-active'); // 👈 remove
    disableDrag();
  }
});

function enableDrag() {
  sortableInstance = new Sortable(todoList, {
    animation: 150,
    onEnd: async () => {
      const listItems = document.querySelectorAll('#todo-list li');
      const newOrder = [];

      listItems.forEach(li => {
        const trueIndex = parseInt(li.getAttribute('data-trueindex'));
        const originalItem = todosData[trueIndex];
        if (originalItem && !originalItem.done) {
          newOrder.push(originalItem);
        }
      });

      const doneItems = todosData.filter(todo => todo.done);
      todosData = [...newOrder, ...doneItems];

      // 🔁 Save reordered list to server
      try {
        await fetch('/todos/reorder', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${localStorage.getItem(ADMIN_PASSWORD_KEY)}`
          },
          body: JSON.stringify(todosData)
        });
      } catch (err) {
        alert('⚠️ Failed to save new order to server.');
      }

      renderTodos();
      renderDone();
    }
  });
}

function disableDrag() {
  if (sortableInstance) {
    sortableInstance.destroy();
    sortableInstance = null;
  }
}
  // Init
  toggleDragBtn.textContent = '↕️Reorder';
  loadTodosFromServer();

  // Stars
  const canvas = document.getElementById("stars");
  const ctx = canvas.getContext("2d");
  let w,h;
  function resizeCanvas(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    w = canvas.width;
    h = canvas.height;
  }
  resizeCanvas();
  let stars = Array.from({length: 300},()=>({x:Math.random()*w,y:Math.random()*h,r:Math.random()*1.5+0.5,d:Math.random()*0.5+0.2}));
  function draw(){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--star-color').trim()||"#fff";
    stars.forEach(s=>{
      ctx.beginPath();
      ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fill();
    });
    move();
  }
  function move(){
    stars.forEach(s=>{
      s.y -= s.d;
      if(s.y<0){s.y=h;s.x=Math.random()*w;}
    });
  }
  function animate(){
    draw();
    requestAnimationFrame(animate);
  }
  animate();
  window.addEventListener('resize', resizeCanvas);

  updateAdminUI();

  exportBtn?.addEventListener('click', async () => {
  try {
    const data = await (await fetch('/todos')).json();
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `todos-${todayISO()}.json`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  } catch {
    alert('Export failed.');
  }
});

importFile?.addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  let arr;
  try { arr = JSON.parse(await file.text()); } catch { return alert('Invalid JSON'); }
  if (!Array.isArray(arr)) return alert('JSON must be an array of tasks');

  // minimal normalization
  arr = arr.map(t => ({ done:false, ...t }));

  try {
    await fetch('/todos/reorder', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${localStorage.getItem(ADMIN_PASSWORD_KEY) || ''}`
      },
      body: JSON.stringify(arr)
    });
    await loadTodosFromServer();
    alert('Imported ✅');
  } catch {
    alert('Import failed (need admin login?).');
  } finally {
    e.target.value = '';
  }
});

</script>
</body>
</html>
