<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>üìù Siah To Do</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="todo.css">
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
</head>
<body>
  <canvas id="stars"></canvas>

  <!-- Theme Toggle -->
  <div id="toggle-theme" class="theme-switch">
    <label class="theme-switch">
      <input type="checkbox" id="toggle-theme-checkbox">
      <span class="slider"></span>
    </label>
  </div>

  <div class="container">
    <div class="top-bar">
      <div class="button-group">
        <button id="enter-password">üîê Enter Password</button>
        <button id="logout">üö™ Logout</button>
      </div>
      <h1><span>‚úÖ</span> Siah To Do</h1>
    </div>
  </div>

  <div class="main-content">
    <!-- To Do List -->
    <div id="todo-container" class="card-container">
      <h2>To Do List</h2>
      <input type="text" id="todo-input" placeholder="Type a task and hit Enter..." />
      <div class="repeat-row">
  <label>Due:
    <input type="date" id="due-input">
  </label>

  <label>Repeat:
    <select id="repeat-select">
      <option value="">None</option>
      <option value="daily">Daily</option>
      <option value="weekly">Weekly</option>
    </select>
  </label>

  <label id="interval-wrap" style="display:none;">Every
    <input type="number" id="interval-input" min="1" value="1" style="width:4rem;">
    <span class="interval-unit">day(s)</span>
  </label>

  <div id="weekly-wrap" style="display:none; gap:.4rem; align-items:center;">
    <span>Days:</span>
    <label><input type="checkbox" value="0" class="byweekday">Su</label>
    <label><input type="checkbox" value="1" class="byweekday">Mo</label>
    <label><input type="checkbox" value="2" class="byweekday">Tu</label>
    <label><input type="checkbox" value="3" class="byweekday">We</label>
    <label><input type="checkbox" value="4" class="byweekday">Th</label>
    <label><input type="checkbox" value="5" class="byweekday">Fr</label>
    <label><input type="checkbox" value="6" class="byweekday">Sa</label>
  </div>
</div>
      <div class="controls">
        <label><input type="checkbox" id="select-all"> Select All</label>
        <button id="delete-btn" onclick="deleteSelected()">
          <span class="emoji">üóëÔ∏è</span> Delete Selected
        </button>
        <button id="undo-btn">‚Ü©Ô∏è Undo</button>
        <button id="toggle-drag">‚ÜïÔ∏è Reorder</button>
      </div>
      <ul id="todo-list"></ul>
    </div>

    <!-- Done List -->
    <div id="done-container" class="card-container">
      <h2>Marked as Done ‚úÖ</h2>
      <ul id="done-list"></ul>
    </div>
  </div>

  <!-- Admin Modal -->
  <div id="admin-modal" class="modal">
    <div class="modal-content">
      <h2>Admin Login</h2>
      <input type="password" id="password-input" placeholder="Password" />
      <div class="modal-buttons">
        <button id="login-btn">Login</button>
        <button id="cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- ‚úÖ Back Button -->
  <div class="back-button-wrapper">
    <a href="https://siahverse.cc/" class="back-button">Back to Portal</a>
  </div>

<script>
  
  const todoInput = document.getElementById('todo-input');
  const todoList = document.getElementById('todo-list');
  const doneList = document.getElementById('done-list');
  const undoBtn = document.getElementById('undo-btn');
  const selectAll = document.getElementById('select-all');
  const themeCheckbox = document.getElementById('toggle-theme-checkbox');
  const dueInput = document.getElementById('due-input');
  const repeatSelect = document.getElementById('repeat-select');
  const intervalWrap = document.getElementById('interval-wrap');
  const intervalInput = document.getElementById('interval-input');
  const intervalUnit = document.querySelector('.interval-unit');
  const weeklyWrap = document.getElementById('weekly-wrap');

repeatSelect.addEventListener('change', () => {
  const v = repeatSelect.value;
  intervalWrap.style.display = v ? '' : 'none';
  intervalUnit.textContent = v === 'weekly' ? 'week(s)' : 'day(s)';
  weeklyWrap.style.display = v === 'weekly' ? 'flex' : 'none';
});
  
  const enterPwBtn = document.getElementById('enter-password');
  const logoutBtn = document.getElementById('logout');
  const adminModal = document.getElementById('admin-modal');
  const loginBtn = document.getElementById('login-btn');
  const cancelBtn = document.getElementById('cancel-btn');
  const passwordInput = document.getElementById('password-input');

  let todosData = [];
  let deletedTodos = [];
  const ADMIN_PASSWORD_KEY = 'adminPassword';

  // Button visibility
function updateAdminUI() {
  const pw = localStorage.getItem(ADMIN_PASSWORD_KEY);
  const isLoggedIn = !!pw;

  document.getElementById('enter-password').style.display = isLoggedIn ? 'none' : 'inline-block';
  document.getElementById('logout').style.display = isLoggedIn ? 'inline-block' : 'none';
}

  // Theme
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'light') {
    document.body.classList.add('light-mode');
    themeCheckbox.checked = true;
  }
  themeCheckbox.addEventListener('change', () => {
    document.body.classList.toggle('light-mode');
    localStorage.setItem('theme', document.body.classList.contains('light-mode') ? 'light' : 'dark');
  });

  // Admin
  enterPwBtn.addEventListener('click', () => adminModal.style.display = 'block');
  cancelBtn.addEventListener('click', () => adminModal.style.display = 'none');
  loginBtn.addEventListener('click', async () => {
  const pw = passwordInput.value.trim();
  if (!pw) return alert("Password cannot be empty.");

  // Send a harmless request to test the password
  const res = await fetch('/todos/0', {
    method: 'DELETE',
    headers: {
      Authorization: `Bearer ${pw}`
    }
  });

  if (res.status === 401) {
    alert("‚ùå Incorrect password.");
  } else {
    localStorage.setItem(ADMIN_PASSWORD_KEY, pw);
    alert("‚úÖ Admin logged in!");
    todoInput.disabled = false;
    adminModal.style.display = 'none';
    updateAdminUI();
  }
});

  logoutBtn.addEventListener('click', () => {
    localStorage.removeItem(ADMIN_PASSWORD_KEY);
    alert("Logged out.");
    todoInput.disabled = true;
    updateAdminUI();
  });
  if (!localStorage.getItem(ADMIN_PASSWORD_KEY)) todoInput.disabled = true;

  // Load Todos from server
async function loadTodosFromServer() {
  try {
    const res = await fetch('/todos');
    todosData = await res.json();

    // Normalize any overdue repeating tasks client-side
    let changed = false;
    for (let i = 0; i < todosData.length; i++) {
      const t = todosData[i];
      if (t && t.repeat) {
        if (rollForwardIfMissed(t)) {
          // persist normalization
          changed = true;
          await fetch(`/todos/${i}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ due: t.due, nextDue: t.nextDue })
          });
        }
      }
    }

    renderTodos();
    renderDone();
  } catch {
    alert("Failed to load todos.");
  }
}

  // ==== Repeats Helpers ====
function todayISO() { return new Date().toISOString().slice(0,10); }

function toISO(d) {
  if (!d) return null;
  if (typeof d === 'string') return d.slice(0,10);
  return new Date(d).toISOString().slice(0,10);
}
function addDays(iso, n){
  const d = new Date(iso || todayISO());
  d.setDate(d.getDate()+n);
  return toISO(d);
}

// Compute the next scheduled date from a given 'from' date
function computeNextDue(task, fromISO) {
  const rep = task.repeat;
  if (!rep) return task.due || null;

  const base = new Date(fromISO || (task.nextDue || task.due || todayISO()));
  if (rep.freq === 'daily') {
    const interval = Math.max(1, rep.interval || 1);
    base.setDate(base.getDate() + interval);
    return toISO(base);
  }
  if (rep.freq === 'weekly') {
    const interval = Math.max(1, rep.interval || 1);
    const days = Array.isArray(rep.byWeekday) && rep.byWeekday.length ? [...rep.byWeekday].sort() : [base.getDay()];
    const todayIdx = base.getDay();

    // find next listed weekday strictly after 'base'
    for (const wd of days) {
      const diff = (wd - todayIdx + 7) % 7;
      if (diff > 0) { base.setDate(base.getDate() + diff); return toISO(base); }
    }
    // none left this week ‚Üí jump to first day in the next interval block
    const first = days[0];
    const toNextBlock = (7 * interval) - ((todayIdx - first + 7) % 7);
    base.setDate(base.getDate() + toNextBlock);
    return toISO(base);
  }
  return task.due || null;
}

// Bring overdue repeating tasks forward to today-or-future
function rollForwardIfMissed(task) {
  if (!task.repeat) return false;
  const next = toISO(task.nextDue || task.due);
  if (!next) return false;

  let cur = next;
  const t = todayISO();
  let moved = false;
  while (cur < t) {
    cur = computeNextDue(task, cur);
    moved = true;
  }
  if (moved) {
    task.nextDue = cur;
    task.due = cur;
  }
  return moved;
}

// Pretty pills for UI
function repeatLabel(task){
  if (!task.repeat) return '';
  if (task.repeat.freq === 'daily') return `Repeats daily (every ${task.repeat.interval||1}d)`;
  if (task.repeat.freq === 'weekly') {
    const map = ['Su','Mo','Tu','We','Th','Fr','Sa'];
    const wd = (task.repeat.byWeekday||[]).map(x=>map[x]).join(',');
    return `Repeats weekly${wd?` (${wd})`:''} (every ${task.repeat.interval||1}w)`;
  }
  return '';
}
  
  // Build weekday checkboxes for the editor
function weekdayBoxes(selected = []) {
  const map = ['Su','Mo','Tu','We','Th','Fr','Sa'];
  return map.map((lbl,i)=>`
    <label style="margin-right:.5rem;">
      <input type="checkbox" class="edit-byweekday" value="${i}" ${selected.includes(i)?'checked':''}>
      ${lbl}
    </label>
  `).join('');
}

// Render Todos
const renderTodos = () => {
  todoList.innerHTML = '';
  todosData.forEach((todo, i) => {
    if (todo.done) return;

    const li = document.createElement('li');
    li.setAttribute('data-trueindex', i);
    li.style.animationDelay = `${Math.random() * 0.5}s`;
   li.innerHTML = `
  <input type="checkbox" class="select-todo" data-trueindex="${i}" />
  <span class="todo-text">${todo.text}</span>
  <div class="todo-meta">
    ${todo.due ? `<span class="pill due">Due: ${toISO(todo.due)}</span>` : ''}
    ${todo.repeat ? `<span class="pill repeat">${repeatLabel(todo)}</span>` : ''}
  </div>
  <div>
    <button onclick="markAsDone(this.closest('li').getAttribute('data-trueindex'))">‚úÖ</button>
    <button onclick="editTodo(this.closest('li').getAttribute('data-trueindex'))">‚úèÔ∏è</button>
    <button onclick="removeTodo(this.closest('li').getAttribute('data-trueindex'))">‚ùå</button>
  </div>`;
    todoList.appendChild(li);
  });

  // Reset Select All
  selectAll.checked = false;

  // Auto-sync Select All if all checkboxes are toggled
  document.querySelectorAll('.select-todo').forEach(cb => {
    cb.addEventListener('change', () => {
      const all = document.querySelectorAll('.select-todo');
      const checked = document.querySelectorAll('.select-todo:checked');
      selectAll.checked = all.length > 0 && checked.length === all.length;
    });
  });
};
  
// Render Done
const renderDone = () => {
  doneList.innerHTML = '';
  todosData.forEach((todo, i) => {
    if (!todo.done) return;

    const li = document.createElement('li');
    li.classList.add('done');
    li.setAttribute('data-trueindex', i);
    li.style.animationDelay = `${Math.random() * 0.5}s`; // ‚úÖ pulse offset

    li.innerHTML = `
      <span>${todo.text}</span>
      <div>
        <button onclick="unmarkDone(${i})">‚Ü©Ô∏è</button>
        <button onclick="removeTodo(${i})">‚ùå</button>
      </div>`;

    doneList.appendChild(li);
  });
};
  
 // Inline editor for text + due + repeat
window.editTodo = function(index){
  const li = document.querySelector(`li[data-trueindex="${index}"]`);
  if (!li) return;
  const todo = todosData[index] || {};

  const text = todo.text ?? '';
  const due = (todo.due || '').toString().slice(0,10);
  const rep = todo.repeat || null;
  const freq = rep?.freq || '';
  const interval = rep?.interval || 1;
  const byWeekday = Array.isArray(rep?.byWeekday) ? rep.byWeekday : [];

  li.innerHTML = `
  <div class="edit-container">
    <input type="text" class="edit-text" value="${text}" />
    <label>Due:
      <input type="date" class="edit-due" value="${due}">
    </label>

        <label>Repeat:
          <select class="edit-repeat">
            <option value="" ${!freq?'selected':''}>None</option>
            <option value="daily" ${freq==='daily'?'selected':''}>Daily</option>
            <option value="weekly" ${freq==='weekly'?'selected':''}>Weekly</option>
          </select>
        </label>

        <label class="edit-interval-wrap" style="${freq?'':'display:none;'}">Every
          <input type="number" class="edit-interval" min="1" value="${interval}" style="width:4rem;">
          <span class="edit-interval-unit">${freq==='weekly'?'week(s)':'day(s)'}</span>
        </label>

        <div class="edit-weekly-wrap" style="display:${freq==='weekly'?'flex':'none'};align-items:center;">
          <span style="margin-right:.25rem;">Days:</span>
          ${weekdayBoxes(byWeekday)}
        </div>
      </div>

      <div style="display:flex;gap:.5rem;">
        <button class="btn-save">Save</button>
        <button class="btn-cancel">Cancel</button>
      </div>
    </div>
  `;

  // toggles
  const sel = li.querySelector('.edit-repeat');
  const intWrap = li.querySelector('.edit-interval-wrap');
  const intUnit = li.querySelector('.edit-interval-unit');
  const weeklyWrap = li.querySelector('.edit-weekly-wrap');

  sel.addEventListener('change', () => {
    const v = sel.value;
    intWrap.style.display = v ? '' : 'none';
    intUnit.textContent = v==='weekly' ? 'week(s)' : 'day(s)';
    weeklyWrap.style.display = v==='weekly' ? 'flex' : 'none';
  });

  // cancel -> re-render
  li.querySelector('.btn-cancel').onclick = () => { renderTodos(); };

  // save -> PATCH
  li.querySelector('.btn-save').onclick = async () => {
    const newText = li.querySelector('.edit-text').value.trim();
    const newDue = li.querySelector('.edit-due').value || null;
    const newFreq = sel.value;
    const newInterval = parseInt(li.querySelector('.edit-interval')?.value || '1',10);

    let repeat = null;
    if (newFreq) {
      repeat = { freq: newFreq, interval: Math.max(1,newInterval) };
      if (newFreq === 'weekly') {
        repeat.byWeekday = [...li.querySelectorAll('.edit-byweekday:checked')].map(cb => parseInt(cb.value,10));
      }
    }

    // Build patch; recompute nextDue when repeating
    const patch = { text: newText || todo.text, due: newDue };
    if (repeat) {
      patch.repeat = repeat;
      const temp = { ...todo, repeat, due: newDue || (todo.due || todayISO()) };
      patch.nextDue = computeNextDue(temp, temp.due);
    } else {
      patch.repeat = null;
      patch.nextDue = null;
    }

    try {
      await fetch(`/todos/${index}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(patch)
      });
      await loadTodosFromServer();
    } catch {
      alert('Failed to save changes.');
    }
  };
};

// Add new todo (supports repeats)
todoInput.addEventListener('keydown', async (e) => {
  if (e.key === 'Enter' && todoInput.value.trim()) {
    if (!localStorage.getItem(ADMIN_PASSWORD_KEY)) return alert("Admin only");

    const text = todoInput.value.trim();
    const due = dueInput.value ? dueInput.value : null;

    let repeat = null;
    if (repeatSelect.value) {
      repeat = {
        freq: repeatSelect.value,                 // 'daily' | 'weekly'
        interval: Math.max(1, parseInt(intervalInput.value || '1',10))
      };
      if (repeatSelect.value === 'weekly') {
        const days = [...document.querySelectorAll('.byweekday:checked')].map(cb => parseInt(cb.value,10));
        repeat.byWeekday = days;
      }
    }

    // Pre-compute nextDue if repeating
    const payload = {
      text,
      done: false,
      due: due || (repeat ? todayISO() : null),
      repeat,
      lastDone: null,
    };
    if (repeat) {
      payload.nextDue = computeNextDue(payload, payload.due);
      payload.due = payload.due || payload.nextDue; // ensure a visible date
    }

    try {
      await fetch('/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      // clear inputs
      todoInput.value = '';
      dueInput.value = '';
      repeatSelect.value = '';
      intervalWrap.style.display = 'none';
      weeklyWrap.style.display = 'none';
      await loadTodosFromServer();
    } catch {
      alert("Failed to add todo.");
    }
  }
});

// Mark as done OR advance repeating task
window.markAsDone = async (index) => {
  const task = todosData[index];
  if (!task) return;

  // If it's a repeating task, advance dates instead of moving to Done
  if (task.repeat) {
    const nowISO = todayISO();
    // set lastDone = today
    const updates = { lastDone: nowISO };

    // Advance nextDue until in the future/today
    const startFrom = toISO(task.nextDue || task.due || nowISO);
    let next = startFrom <= nowISO ? computeNextDue(task, startFrom) : startFrom;

    // If still <= today, loop forward
    while (next <= nowISO) {
      // Simulate the updated task for computeNextDue (use the same repeat config)
      next = computeNextDue({ repeat: task.repeat, nextDue: next, due: next }, next);
    }
    updates.nextDue = next;
    updates.due = next;

    try {
      await fetch(`/todos/${index}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      await loadTodosFromServer();
    } catch {
      alert("Failed to advance repeating task.");
    }
    return;
  }

  // Non-repeating: behave as before
  try {
    await fetch(`/todos/${index}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ done: true })
    });
    await loadTodosFromServer();
  } catch {
    alert("Failed to mark as done.");
  }
};

  //Unmark done
window.unmarkDone = async (index) => {
  try {
    await fetch(`/todos/${index}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ done: false })
    });
    await loadTodosFromServer();
  } catch {
    alert("Failed to move back to To Do.");
  }
};

  // Remove todo
  window.removeTodo = async (i) => {
    if (!localStorage.getItem(ADMIN_PASSWORD_KEY)) return alert("Admin only");
    deletedTodos.push(todosData[i]); // save full object
    try {
      await fetch(`/todos/${i}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${localStorage.getItem(ADMIN_PASSWORD_KEY)}`
        }
      });
      await loadTodosFromServer();
    } catch {
      alert("Failed to delete.");
    }
  };

  // Undo button
 undoBtn.addEventListener('click', async () => {
  if (!deletedTodos.length) return;

  const restoring = [...deletedTodos]; // Clone to avoid timing issues
  deletedTodos = [];

for (const obj of restoring) {
  await fetch('/todos', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(obj) // send full object
  });
}

  loadTodosFromServer();
});

  // Select all checkbox
  selectAll.addEventListener('change', (e) => {
    document.querySelectorAll('.select-todo').forEach(cb => cb.checked = e.target.checked);
  });

  window.deleteSelected = () => {
    if (!localStorage.getItem(ADMIN_PASSWORD_KEY)) return alert("Admin only");
    const selected = [...document.querySelectorAll('.select-todo:checked')].map(cb => parseInt(cb.dataset.trueindex));
    selected.sort((a,b) => b-a);
    selected.forEach(i => {
      window.removeTodo(i);
    });
  };

  //Toggle Drag mode
let dragEnabled = false;
let sortableInstance = null;

const toggleDragBtn = document.getElementById('toggle-drag');

toggleDragBtn.addEventListener('click', () => {
  dragEnabled = !dragEnabled;

  if (dragEnabled) {
    toggleDragBtn.textContent = '‚ÜïÔ∏è Reordering...';
    document.body.classList.add('dragging-active'); // üëà add this
    enableDrag();
  } else {
    toggleDragBtn.textContent = '‚ÜïÔ∏è Reorder';
    document.body.classList.remove('dragging-active'); // üëà remove
    disableDrag();
  }
});

function enableDrag() {
  sortableInstance = new Sortable(todoList, {
    animation: 150,
    onEnd: async () => {
      const listItems = document.querySelectorAll('#todo-list li');
      const newOrder = [];

      listItems.forEach(li => {
        const trueIndex = parseInt(li.getAttribute('data-trueindex'));
        const originalItem = todosData[trueIndex];
        if (originalItem && !originalItem.done) {
          newOrder.push(originalItem);
        }
      });

      const doneItems = todosData.filter(todo => todo.done);
      todosData = [...newOrder, ...doneItems];

      // üîÅ Save reordered list to server
      try {
        await fetch('/todos/reorder', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${localStorage.getItem('adminPassword')}`
          },
          body: JSON.stringify(todosData)
        });
      } catch (err) {
        alert('‚ö†Ô∏è Failed to save new order to server.');
      }

      renderTodos();
      renderDone();
    }
  });
}

function disableDrag() {
  if (sortableInstance) {
    sortableInstance.destroy();
    sortableInstance = null;
  }
}
  // Init
  toggleDragBtn.textContent = '‚ÜïÔ∏èReorder';
  loadTodosFromServer();

  // Stars
  const canvas = document.getElementById("stars");
  const ctx = canvas.getContext("2d");
  let w,h;
  function resizeCanvas(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    w = canvas.width;
    h = canvas.height;
  }
  resizeCanvas();
  let stars = Array.from({length: 300},()=>({x:Math.random()*w,y:Math.random()*h,r:Math.random()*1.5+0.5,d:Math.random()*0.5+0.2}));
  function draw(){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--star-color').trim()||"#fff";
    stars.forEach(s=>{
      ctx.beginPath();
      ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fill();
    });
    move();
  }
  function move(){
    stars.forEach(s=>{
      s.y -= s.d;
      if(s.y<0){s.y=h;s.x=Math.random()*w;}
    });
  }
  function animate(){
    draw();
    requestAnimationFrame(animate);
  }
  animate();
  window.addEventListener('resize', resizeCanvas);

  updateAdminUI();
</script>
</body>
</html>
